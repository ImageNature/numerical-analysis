% !TeX encoding = UTF-8
% !TeX TS-program = xelatex

\documentclass[12pt,a4paper,final,twoside,fleqn]{book}
\newcommand{\bookauthor}{姜青娥}
\newcommand{\booktitleI}{数值分析及代码手册}
\newcommand{\booktitleII}{Cpp etc}
\newcommand{\booktitle}{\booktitleI{} \booktitleII}
\newcommand{\booksubtitle}{}
\newcommand{\bookinstitution}{克莱登大学}
\newcommand{\bookedition}{ImageNature}
\newcommand{\bookversion}{ver 1}
\newcommand{\bookkeywords}{Math}
\newcommand{\bookemail}{imagenature@proton.me}
\usepackage{mycode}
\linespread{1.25}\selectfont

\begin{document}
%\raggedbottom
%\maketitle
\frontmatter
\maketitle
\input{copyright}

\tableofcontents
\mainmatter
\chapter{Cpp 基础}
\label{cha:cpp-base}
%\thispagestyle{empty}

%% Calculate how old C is...
\newcount\cdifference\cdifference=\the\year\advance\cdifference by -1970

引用\cite{1989programming}

\begin{code}
  type 'a Process = 'a Signal IObservable
  type 'a Process = 'a Signal IObservable
\end{code}
\cs{love}

\cs{for (i=0; i<5; i++) if (i==0);for (i=0; i<5; i++) if (i==0)for (i=0; i<5; i++) \\ if (i==0)for (i=0; i<5; i++) if (i==0)for (i=0; i<5; i++) if (i==0)}


C is al een oude taal. De taal is rond 1970 ontworpen door Dennis Ritchie\footnote{Dennis MacAlister Ritchie (1941 -- 2011). Hij was de ontwerper van de programmeertaal C en was een van de ontwerpers van Unix. Bekende afgeleiden van Unix zijn Linux en FreeBSD.} en is dus al zo'n \the\cdifference\ jaar oud.

\begin{infobox}[{Bits and bytes{,} size does matter...}]
  De meeste gangbare computersystemen slaan data op in \textsl{bytes}. Een byte is een eenheid van~8 \textsl{bits}. Het woord \textsl{bit} is een samentrekking van \textsl{binary digit}. Binary digit betekent \textsl{binair cijfer} en binair betekent \textsl{tweewaardig}. Dat betekent dat een bit twee verschillende waarden kan hebben. We noemen die waarden 0 of 1. Met behulp van bits en bytes kunnen we getallen representeren. Het kleinste getal in een byte is 00000000$_2$ waarbij het subscript 2 aangeeft dat het om een binair getal gaat, en het grootste getal is 11111111$_2$. Het getal 00000000$_2$ komt overeen met het decimale getal 0 en 11111111$_2$ komt overeen met 255. Om grotere getallen te representeren, zijn meerdere bytes nodig. Moderne systemen kunnen \textsl{van nature} overweg met 32-bits eenheden, ze kunnen met 32 bits als één eenheid rekenen. Daarvoor zijn 4 bytes nodig. We spreken dan van een \textsl{32-bits systeem}. Daarnaast kunnen veel systemen ook overweg met 64-bits eenheden, dus zijn er 8 bytes nodig voor zo'n eenheid. We noemen dat\footnote{Een programmeerparadigma is een manier van programmeren en een wijze waarop een programma wordt vormgegeven.}. een \textsl{64-bits systeem}.
\end{infobox}

\begin{dosbox}[title=Een voorbeeld van een command line interface.,label=fig:commandlineint]
  C:\Users\Cbook> (*\textbf{notepad mooi.c}*) (*\hfill\textrm{(start Notepad)} *)
  C:\Users\Cbook> (*\textbf{gcc -o mooi.exe mooi.c}*) (*\hfill\textrm{(start C-compiler)}*)
  C:\Users\Cbook> (*\textbf{.\textbackslash mooi.exe}*) (*\hfill\textrm{(start uitvoerbaar programma)}*)
  C is een mooie taal (*\hfill\textrm{(de uitvoer op het scherm)}*)
  C:\Users\Cbook>
\end{dosbox}
Dit is echter niet de werkwijze van veel programmeurs. Gelukkig zijn er goede ontwikkelsystemen (IDE: Integrated Development Environment) die het programmeerwerk verlichten. Bekende systemen zijn Microsoft Visual Studio~\cite{vs2022}, Code::Blocks~\cite{codeblocks2020} en Apple's Xcode~\cite{xcode2020}.

Zulke ontwikkelsystemen zorgen ervoor dat de programmeur gemakkelijk het programma kan invoeren, de compiler kan starten en het programma kan \textsl{debuggen}\index{debuggen}. Dat laatste is vaak nodig als blijkt dat de executie van een programma niet verloopt zoals de programmeur het voor ogen had. Met debuggen wordt het programma stap voor stap doorlopen en kan de programmeur (of is het debugger) de inhoud van \textsl{variabelen}\index{variabele} bekijken. Ook kan de programmeur bepalen of de \textsl{statements}

 Een voorbeeld is te zien in figuur~\ref{fig:commandlineint}.


\begin{dosbox}[title=Een voorbeeld van een command line interface.,label=fig:commandlineint]
  C:\Users\Cbook> (*\textbf{notepad mooi.c}*) (*\hfill\textrm{(start Notepad)} *)
  C:\Users\Cbook> (*\textbf{gcc -o mooi.exe mooi.c}*) (*\hfill\textrm{(start C-compiler)}*)
  C:\Users\Cbook> (*\textbf{.\textbackslash mooi.exe}*) (*\hfill\textrm{(start uitvoerbaar programma)}*)
  C is een mooie taal (*\hfill\textrm{(de uitvoer op het scherm)}*)
  C:\Users\Cbook>
\end{dosbox}

\begin{dosbox}[title=Uitvoer van het programma in listing~\ref{cod:sumoftwo}.,label=fig:unuitvoerprog]
  Geef een getal: (*\textbf{7}*)
  Geef nog een getal: (*\textbf{4}*)
  De som van 7 en 4 is 11
\end{dosbox}
\begin{infobox}[To \texttt{scanf} or not to \texttt{scanf}...]
  \label{fig:unopmerkingscanf}%
  De Microsoft C-compiler bestempelt \texttt{scanf} als ``onveilig''. Een compilatie met \texttt{scanf} zal eindigen met een foutmelding. In plaats daarvan moet de functie \texttt{scanf\_s} worden gebruikt. Helaas ondersteunen andere compilers deze functie niet. Dat zal resulteren in een programma dat niet door iedere compiler kan worden vertaald. Om het probleem te omzeilen hebben we gebruik gemaakt van een \textsl{pragma}:

  \hspace*{1em}\texttt{\#pragma warning(disable : 4996)}

  We geven aan dat de C-compiler fout 4996 moet negeren. Op andere compilers, bijvoorbeeld de GNU-C compiler, wordt deze regel overgeslagen (er volgt wel een waarschuwing en met behulp van \textsl{conditionele compilatie} kan deze pragma overgeslagen worden). Overigens wordt op vele fora gewaarschuwd voor de onveiligheid van \texttt{scanf} en worden alternatieven gegeven. Wij gebruiken \texttt{scanf} hier wel \textsl{for the sake of simplicity}. Het is beter om \texttt{scanf} te vermijden.
\end{infobox}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\textwidth]{images/vs2019}
  \caption{Voorbeeld van Microsoft Visual Studio.}
  \label{fig:unvs2019}
\end{figure}
%\lipsum[1-5]

\begin{figure}[H]
  \begin{lstlisting}[caption=Een minimaal C-programma.,label=cod:unminimaalcprogramma]
    int main(void)
    {
      return 0;
    }
  \end{lstlisting}
\end{figure}


Het C-programma begint met de definitie van de \textsl{functie} \texttt{main}\indextwo{main}{functie}. Een functie is een aantal instructies samengepakt onder een gemeenschappelijke noemer. \textsl{Elk C-programma heeft een functie \texttt{main}}. Tussen de haken staat het keyword \texttt{void}\indexkeyword{void}, dat aangeeft dat het uitvoerbaar programma geen gegevens meekrijgt van het besturingssysteem\footnote{Dat kan wel, zie hoofdstuk~\ref{cha:pointers}.}. Vóór \texttt{main} staat het keyword \texttt{int}\indexkeyword{int} dat aangeeft dat \texttt{main} een geheel getal teruggeeft aan het besturingssysteem.





Binnen \texttt{main} zien we één \textsl{statement}\index{statement}. Een statement is een opdracht in de C-taal. Het statement wordt gevormd door het keyword \texttt{return}\indexkeyword{return} gevolgd door het getal 0 en een punt-komma. Bij uitvoering van dit statement wordt de waarde 0 teruggegeven aan het besturingssysteem. Dat behoeft enige uitleg. Een (gecompileerd) programma wordt gestart door het besturingssysteem. Aan het einde wordt het programma afgesloten. Het besturingssysteem ``ruimt'' het programma op en zorgt ervoor dat het gebruikte geheugen weer vrijgegeven wordt voor volgende programma's. We kunnen aan het besturingssysteem een getal teruggeven, in dit geval~0. Het is aan het besturingssysteem om hier wat mee te doen. Gebruikelijk is om 0 terug te geven als alles goed verlopen is. Een ander getal dan 0 geeft over het algemeen aan dat er iets fout gegaan is. Vanaf C99 is het niet meer nodig om dit \texttt{return}-statement uit te voeren. Dan wordt automatisch het getal 0 teruggegeven.



\begin{figure}[!ht]
  \begin{lstlisting}[caption=Afdrukken van de som van twee getallen.,label=cod:uneersteprogramma]
    #include <stdio.h>

    int main(void)
    {
      int a = 3;
      int b = 7;

      int som;

      som = a + b;

      printf("De som van %d en %d is %d\n", a, b, som);

      return 0;
    }
  \end{lstlisting}
\end{figure}

\begin{figure}
  \lstinputlisting[label=cod:uneerst,tabsize=4,language=c,caption={[Code2] An very important code}]{main.cpp}
\end{figure}

In regel 1 wordt een zogenoemd \textsl{header-bestand}\index{header-bestand} geladen, in dit geval het bestand \texttt{stdio.h}\indextwo{stdio.h}{header-bestand}. We leggen zo meteen uit waarom dat nodig is.

In regel 3 wordt kenbaar gemaakt dat het programma de functie \texttt{main}\indextwo{main}{functie} heeft. Een C-programma heeft \textsl{altijd} de functie \texttt{main}. Het (gecompileerde) programma wordt hier gestart. Het programma wordt gestopt na het laatste statement in \texttt{main}. Dit is per definitie een \mbox{\texttt{return}}-statement.

 dit geval \texttt{\textbackslash n}. Dit zorgt ervoor dat een volgende afdruk wordt begonnen aan het begin van de volgende rege

We kunnen het vorige programma interessanter maken door aan de gebruiker te vragen om twee gehele getallen in te voeren. Naast het afdrukken van tekst met de functie \texttt{printf} maken we nu ook gebruik van de functie \texttt{scanf}\indexfunc{scanf} om gehele getallen in te lezen. Het programma is te zien in listing~\ref{cod:sumoftwo}.

\booklistingfromproject[]{C}{Programma om de som van twee getallen te bepalen}{sumoftwo}{c}{!ht}

r op pagina~\pageref{fig:unopmerkingscanf}.


\section{Keywords}
In tabel~\ref{tab:unkeywords} is een lijst te zien met gereserveerde woorden. Een aantal van deze woorden hebben we al gezien zoals \texttt{int}, \texttt{void} en \texttt{return}. Deze woorden worden \textsl{keywords}\index{keyword} genoemd en vormen de vocabulaire van de taal C.

\begin{table}[!ht]
  \caption{Een lijst met keywords in de C-taal.}
  \label{tab:unkeywords}
  \centering\ttfamily
  \begin{tabular}{p{2.5cm}p{2.5cm}p{2.5cm}p{2.5cm}}
    \toprule
    auto &  double &  int & struct \\
    break & else  & long  &  switch \\
    case & enum & register & typedef \\
    char & extern & return & union \\
    const & float & short &  unsigned \\
    continue & for & signed & void \\
    default & goto & sizeof & volatile \\
    do & if & static & while \\
    \bottomrule
  \end{tabular}
\end{table}



Met behulp van de keywords \texttt{if}\indexkeyword{if} en \texttt{else}\indexkeyword{else} kunnen we in het programma beslissingen nemen op basis van een \textsl{conditie}\index{conditie}. Dit is te zien in listing~\ref{cod:unif}. We definiëren twee variabelen \texttt{a} en \texttt{b} en kennen gelijk de waarden
\begin{lstlisting}[style=lstoneline]
  unsigned long int a;
\end{lstlisting}

\begin{figure}[!b]
  \begin{lstlisting}[caption=Afdrukken van tekst op basis van een beslissing.,label=cod:unif]
    #include <stdio.h>

    int main(void)
    {
      int a = 7;
      int b = 9;

      if (a < b)
      {
        printf("a is kleiner dan b\n");
      }

      return 0;
    }
  \end{lstlisting}
\end{figure}


Technisch gezien hoort de \texttt{else} in regel 18 bij de \texttt{if} in regel 14. Let erop dat het vergelijken van \texttt{a} en \texttt{b} op gelijkheid in regel 12 een \textsl{dubbele is-gelijk-teken} (\texttt{==})\indexop{==} bevat.




\booklistingfromproject[]{C}{Afdrukken van de kwadraten van 1 t/m 10.}{printkwadraten}{c}{!ht}



\begin{figure}[!ht]
  \begin{lstlisting}[caption=Gebruik van een \texttt{for}-statement.,label=cod:unfor]
    for (getal = ondergrens; getal <= bovengrens;
    getal = getal + stap)
    {
      printf("Het kwadraat van %3d is %3d\n",
      getal, getal * getal);
    }
  \end{lstlisting}
\end{figure}

vergelijking~\eqref{equ:sqrtbab}.
%
\begin{equation}
  \label{equ:sqrtbab}
  \begin{split}
    x_0 &= S &&&& \text{beginsituatie} \\
    x_{n+1} &= \dfrac{1}{2}\cdot\left(x_n + \dfrac{S}{x_n}\right) &&&& \text{nieuwe situatie}\\
    \sqrt{S} &= \lim_{n\rightarrow\infty} x_n &&&& \text{uiteindelijke resultaat}
  \end{split}
\end{equation}


\begin{lstlisting}[caption=Voorbeeld van een string.]
  char str[] = "Ik ben een string";
\end{lstlisting}




\begin{lstlisting}[caption=Voorbeeld van een string.]
  char str[] = "Ik ben een string";
\end{lstlisting}

We hoeven de lengte van de string in dit geval niet op te geven, dat wordt automatisch door de C-compiler uitgerekend. Dat C functies heeft voor het afhandelen van string is te zien in listing~\ref{cod:intexamplestrlen}. In dit programma gebruiken we de functie \lstinline|strlen| (string length) om de lente van de string te bepalen. Wel moeten we het header-bestand \lstinline|string.h| laden waarin de stringfuncties gedeclareerd zijn.

\begin{lstlisting}[caption=Voorbeeld van een stringfunctie.,label=cod:intexamplestrlen]
  #include <stdio.h>
  #include <string.h>

  int main(void)
  {
    char string[] = "Ik ben een string";

    int len = strlen(string);

    printf("De lengte is %d\n", len);

    return 0;
  }
\end{lstlisting}

Strings worden behandeld in hoofdstuk~\ref{cha:arrays}.

\begin{figure}[!ht]
  \begin{lstlisting}[caption=K\&R-stijl.]
    while (a < b) {
      (*\normalfont\textsl{statements}*)
      if (a < 0) {
        (*\normalfont\textsl{statements}*)
      }
    }
  \end{lstlisting}

\end{figure}
In de Allman-stijl\index{Allman-stijl} wordt de accolade-openen \textsl{onder} een functie, beslissings- of herhalingstatement geschreven. De statement hierbinnen worden \textsl{ingesprongen}. Bij gebruik van in elkaar verweven beslissings- of herhalingstatement worden de statement verder of dieper ingesprongen.

\begin{lstlisting}[caption=Allman-stijl.]
  if (a < b)
  {
    if (a < 0)
    {
      (*\normalfont\textsl{statements}*)
    }
  }
\end{lstlisting}












\blinddocument
%\input{book_chap01}
%\input{book_chap12}







\zhlipsum[2-8]





\printbibliography
\appendix
\frontmatter



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%%       INDEX
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Add index to toc with clickable reference
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{\indexname}
% Next doesn't work with imakeidx, use \indexsetup{othercode=\thispagestyle{fancy}}
%\thispagestyle{fancy}

%% Just a nice trick to get ``recursie'' in the index, pointing to itself ;-)
\newcommand{\indexownpage}[1]{\textcolor{bookcolor}{\thepage}}
\printindex\index{recursie|indexownpage}


\end{document}